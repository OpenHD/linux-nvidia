diff -Naur kernel/nvidia/drivers/media/i2c/imx477.c kernel_new/nvidia/drivers/media/i2c/imx477.c
--- kernel/nvidia/drivers/media/i2c/imx477.c	2021-02-19 08:38:22.000000000 -0800
+++ kernel_new/nvidia/drivers/media/i2c/imx477.c	2021-11-28 21:19:20.806965387 -0800
@@ -1,9 +1,7 @@
 /*
  * imx477.c - imx477 sensor driver
  *
- * Copyright (c) 2020, RidgeRun. All rights reserved.
- *
- * Contact us: support@ridgerun.com
+ * Copyright (c) 2016-2021, NVIDIA CORPORATION.  All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
@@ -29,32 +27,64 @@
 
 #include <media/tegra_v4l2_camera.h>
 #include <media/tegracam_core.h>
-#include <media/imx477.h>
-
-#include "../platform/tegra/camera/camera_gpio.h"
 #include "imx477_mode_tbls.h"
+#define CREATE_TRACE_POINTS
+
+#define IMX477_MIN_FRAME_LENGTH			(1125)
+#define IMX477_MAX_FRAME_LENGTH			(0x65535d)
+#define IMX477_DEFAULT_FRAME_LENGTH    (1551)
+
+#define IMX477_FRAME_LENGTH_ADDR_MSB		0x0340
+#define IMX477_FRAME_LENGTH_ADDR_LSB		0x0341
+#define IMX477_COARSE_TIME_SHS1_ADDR_MSB	0x0202
+#define IMX477_COARSE_TIME_SHS1_ADDR_LSB	0x0203
+
+#define IMX477_GROUP_HOLD_ADDR				0x0104
+
+/*
+ * shift and mask constants
+ */
+#define IMX477_SHIFT_8_BITS				(8)
+#define IMX477_SHIFT_16_BITS			(16)
+#define IMX477_MASK_LSB_2_BITS			(0x03)
+#define IMX477_MASK_LSB_3_BITS			(0x07)
+#define IMX477_MASK_LSB_4_BITS			(0x0f)
+#define IMX477_MASK_LSB_8_BITS			(0x00ff)
+
+#define IMX477_ANALOG_GAIN_ADDR_LSB		0x0205 /* ANALOG GAIN LSB */
+#define IMX477_ANALOG_GAIN_ADDR_MSB		0x0204 /* ANALOG GAIN MSB */
+#define IMX477_DIGITAL_GAIN_REG_LOW		0x020F /* Digital Gain */
+#define IMX477_DIGITAL_GAIN_REG_HIG		0x020E /* Digital Gain */
+
+#define IMX477_GAIN_CONST				(1024) /* for gain formula */
+#define IMX477_GAIN_SHIFT				(8)
+#define IMX477_GAIN_REG_MAX				(978)
+#define IMX477_MAX_DIGITAL_GAIN			(16)
+#define IMX477_MAX_ANALOG_GAIN			(22)
+#define IMX477_MIN_GAIN					(1)
+#define IMX477_MAX_GAIN					(354)
 
 static const struct of_device_id imx477_of_match[] = {
-	{.compatible = "ridgerun,imx477",},
-	{},
+	{ .compatible = "nvidia,imx477",},
+	{ },
 };
-
 MODULE_DEVICE_TABLE(of, imx477_of_match);
 
 static const u32 ctrl_cid_list[] = {
 	TEGRA_CAMERA_CID_GAIN,
 	TEGRA_CAMERA_CID_EXPOSURE,
 	TEGRA_CAMERA_CID_FRAME_RATE,
+	TEGRA_CAMERA_CID_HDR_EN,
 	TEGRA_CAMERA_CID_SENSOR_MODE_ID,
 };
 
 struct imx477 {
-	struct i2c_client *i2c_client;
-	struct v4l2_subdev *subdev;
-	u16 fine_integ_time;
-	u32 frame_length;
-	struct camera_common_data *s_data;
-	struct tegracam_device *tc_dev;
+	struct i2c_client	*i2c_client;
+	struct v4l2_subdev	*subdev;
+	u32				frame_length;
+	s64 last_wdr_et_val;
+	struct camera_common_data	*s_data;
+	struct tegracam_device		*tc_dev;
 };
 
 static const struct regmap_config sensor_regmap_config = {
@@ -64,61 +94,73 @@
 	.use_single_rw = true,
 };
 
-static inline void imx477_get_frame_length_regs(imx477_reg * regs,
-						u32 frame_length)
+static inline void imx477_get_frame_length_regs(imx477_reg *regs,
+				u32 frame_length)
 {
 	regs->addr = IMX477_FRAME_LENGTH_ADDR_MSB;
 	regs->val = (frame_length >> 8) & 0xff;
+
 	(regs + 1)->addr = IMX477_FRAME_LENGTH_ADDR_LSB;
 	(regs + 1)->val = (frame_length) & 0xff;
 }
 
-static inline void imx477_get_coarse_integ_time_regs(imx477_reg * regs,
-						     u32 coarse_time)
+static inline void imx477_get_coarse_time_regs_shs1(imx477_reg *regs,
+				u32 coarse_time)
 {
-	regs->addr = IMX477_COARSE_INTEG_TIME_ADDR_MSB;
+	regs->addr = IMX477_COARSE_TIME_SHS1_ADDR_MSB;
 	regs->val = (coarse_time >> 8) & 0xff;
-	(regs + 1)->addr = IMX477_COARSE_INTEG_TIME_ADDR_LSB;
+
+	(regs + 1)->addr = IMX477_COARSE_TIME_SHS1_ADDR_LSB;
 	(regs + 1)->val = (coarse_time) & 0xff;
 }
 
-static inline void imx477_get_gain_reg(imx477_reg * reg, u16 gain)
+static inline void imx477_get_gain_reg(imx477_reg *regs,
+				u16 gain)
 {
-	reg->addr = IMX477_ANALOG_GAIN_ADDR_MSB;
-	reg->val = (gain >> IMX477_SHIFT_8_BITS) & IMX477_MASK_LSB_2_BITS;
+	regs->addr = IMX477_ANALOG_GAIN_ADDR_MSB;
+	regs->val = (gain >> IMX477_SHIFT_8_BITS) & IMX477_MASK_LSB_2_BITS;
 
-	(reg + 1)->addr = IMX477_ANALOG_GAIN_ADDR_LSB;
-	(reg + 1)->val = (gain) & IMX477_MASK_LSB_8_BITS;
+	(regs + 1)->addr = IMX477_ANALOG_GAIN_ADDR_LSB;
+	(regs + 1)->val = (gain) & IMX477_MASK_LSB_8_BITS;
 }
 
+static int test_mode;
+module_param(test_mode, int, 0644);
+
 static inline int imx477_read_reg(struct camera_common_data *s_data,
-				  u16 addr, u8 * val)
+				u16 addr, u8 *val)
 {
 	int err = 0;
 	u32 reg_val = 0;
 
 	err = regmap_read(s_data->regmap, addr, &reg_val);
-	*val = reg_val & 0xff;
+	*val = reg_val & 0xFF;
 
 	return err;
 }
 
-static inline int imx477_write_reg(struct camera_common_data *s_data,
-				   u16 addr, u8 val)
+static int imx477_write_reg(struct camera_common_data *s_data,
+				u16 addr, u8 val)
 {
 	int err = 0;
+	struct device *dev = s_data->dev;
 
 	err = regmap_write(s_data->regmap, addr, val);
 	if (err)
-		dev_err(s_data->dev, "%s: i2c write failed, 0x%x = %x",
+		dev_err(dev, "%s: i2c write failed, 0x%x = %x\n",
 			__func__, addr, val);
 
 	return err;
 }
 
-static int imx477_write_table(struct imx477 *priv, const imx477_reg table[])
+static int imx477_write_table(struct imx477 *priv,
+				const imx477_reg table[])
 {
-	return regmap_util_write_table_8(priv->s_data->regmap, table, NULL, 0,
+	struct camera_common_data *s_data = priv->s_data;
+
+	return regmap_util_write_table_8(s_data->regmap,
+					 table,
+					 NULL, 0,
 					 IMX477_TABLE_WAIT_MS,
 					 IMX477_TABLE_END);
 }
@@ -129,83 +171,77 @@
 	struct device *dev = tc_dev->dev;
 	int err;
 
-	dev_dbg(dev, "%s: Setting group hold control to: %u\n", __func__, val);
-
-	err = imx477_write_reg(s_data, IMX477_GROUP_HOLD_ADDR, val);
+	err = imx477_write_reg(s_data,
+				IMX477_GROUP_HOLD_ADDR, val);
 	if (err) {
-		dev_err(dev, "%s: Group hold control error\n", __func__);
+		dev_dbg(dev,
+			"%s: Group hold control error\n", __func__);
 		return err;
 	}
 
 	return 0;
 }
 
-static int imx477_get_fine_integ_time(struct imx477 *priv, u16 * fine_time)
+static int imx477_set_digital_gain(struct camera_common_data *s_data, u32 dgain)
 {
-	struct camera_common_data *s_data = priv->s_data;
-	int err = 0;
-	u8 reg_val[2];
+	int ret;
 
-	err = imx477_read_reg(s_data, IMX477_FINE_INTEG_TIME_ADDR_MSB,
-			      &reg_val[0]);
-	if (err)
-		goto done;
-
-	err = imx477_read_reg(s_data, IMX477_FINE_INTEG_TIME_ADDR_LSB,
-			      &reg_val[1]);
-	if (err)
-		goto done;
-
-	*fine_time = (reg_val[0] << 8) | reg_val[1];
-
-done:
-	return err;
+	ret = imx477_write_reg(s_data, IMX477_DIGITAL_GAIN_REG_LOW,
+			       dgain & IMX477_MASK_LSB_8_BITS);
+	ret |= imx477_write_reg(s_data, IMX477_DIGITAL_GAIN_REG_HIG,
+			       (dgain >> 8) & IMX477_MASK_LSB_8_BITS);
+	return ret;
 }
 
 static int imx477_set_gain(struct tegracam_device *tc_dev, s64 val)
 {
 	struct camera_common_data *s_data = tc_dev->s_data;
-	struct device *dev = s_data->dev;
+	struct device *dev = tc_dev->dev;
 	const struct sensor_mode_properties *mode =
-	    &s_data->sensor_props.sensor_modes[s_data->mode_prop_idx];
-	int err = 0, i = 0;
-	imx477_reg gain_reg[2];
-	s16 gain;
-
-	dev_dbg(dev, "%s: Setting gain control to: %lld\n", __func__, val);
-
-	if (val < mode->control_properties.min_gain_val)
-		val = mode->control_properties.min_gain_val;
-	else if (val > mode->control_properties.max_gain_val)
-		val = mode->control_properties.max_gain_val;
-
-	/* Gain Formula:
-	   Gain = (IMX477_GAIN_C0 - (IMX477_GAIN_C0 * gain_factor / val))
-	 */
-	gain =
-	    (s16) (IMX477_ANALOG_GAIN_C0 -
-		   (mode->control_properties.gain_factor *
-		    IMX477_ANALOG_GAIN_C0 / val));
-
-	if (gain < IMX477_MIN_GAIN)
-		gain = IMX477_MAX_GAIN;
-	else if (gain > IMX477_MAX_GAIN)
-		gain = IMX477_MAX_GAIN;
-
-	dev_dbg(dev, "%s: val: %lld (/%d) [times], gain: %u\n",
-		__func__, val, mode->control_properties.gain_factor, gain);
-
-	imx477_get_gain_reg(gain_reg, (u16) gain);
-
-	for (i = 0; i < ARRAY_SIZE(gain_reg); i++) {
-		err = imx477_write_reg(s_data, gain_reg[i].addr,
-				       gain_reg[i].val);
-		if (err) {
-			dev_err(dev, "%s: gain control error\n", __func__);
-			break;
-		}
+		&s_data->sensor_props.sensor_modes[s_data->mode_prop_idx];
+	imx477_reg reg_list[2];
+	int err, i;
+	u32 gain, analog_gain, digital_gain, gain_reg;
+
+	gain = (u32)(val * 256 / mode->control_properties.gain_factor);
+	if (gain > IMX477_MAX_DIGITAL_GAIN * IMX477_MAX_ANALOG_GAIN * 256)
+		gain = IMX477_MAX_DIGITAL_GAIN * IMX477_MAX_ANALOG_GAIN * 256;
+	else if (gain < IMX477_MIN_GAIN * 256)
+		gain = IMX477_MIN_GAIN * 256;
+
+	if (gain > (IMX477_MAX_ANALOG_GAIN << IMX477_GAIN_SHIFT)) {
+		analog_gain = IMX477_MAX_ANALOG_GAIN << IMX477_GAIN_SHIFT;
+		digital_gain = gain / IMX477_MAX_ANALOG_GAIN;
+	} else {
+		analog_gain = gain;
+		digital_gain = 256;
+	}
+
+	dev_dbg(dev, "%s :val = %lld, digital gain = %d, analog gain = %d\n",
+		 __func__, val, digital_gain, analog_gain);
+
+	err = imx477_set_digital_gain(s_data, digital_gain);
+	if (err)
+		goto fail;
+
+	/* convert to register value, refer to imx477 datasheet */
+	gain_reg = IMX477_GAIN_CONST - ((u32)IMX477_GAIN_CONST << IMX477_GAIN_SHIFT) / analog_gain;
+
+	if (gain_reg > IMX477_GAIN_REG_MAX)
+		gain_reg = IMX477_GAIN_REG_MAX;
+
+	imx477_get_gain_reg(reg_list, (u16)gain_reg);
+
+	for (i = 0; i < ARRAY_SIZE(reg_list); i++) {
+		err = imx477_write_reg(s_data, reg_list[i].addr,
+			 reg_list[i].val);
+		if (err)
+			goto fail;
 	}
+	return 0;
 
+fail:
+	dev_info(dev, "%s: GAIN control error\n", __func__);
 	return err;
 }
 
@@ -214,91 +250,76 @@
 	struct camera_common_data *s_data = tc_dev->s_data;
 	struct imx477 *priv = (struct imx477 *)tc_dev->priv;
 	struct device *dev = tc_dev->dev;
-	const struct sensor_mode_properties *mode =
-	    &s_data->sensor_props.sensor_modes[s_data->mode_prop_idx];
-
-	int err = 0;
-	imx477_reg fl_regs[2];
+	imx477_reg reg_list[2];
+	int err;
 	u32 frame_length;
-	int i;
-
-	dev_dbg(dev, "%s: Setting framerate control to: %lld\n", __func__, val);
+	const struct sensor_mode_properties *mode =
+		&s_data->sensor_props.sensor_modes[s_data->mode_prop_idx];
+	int i = 0;
+return 0;
+	frame_length = mode->signal_properties.pixel_clock.val *
+		mode->control_properties.framerate_factor /
+		mode->image_properties.line_length / val;
 
-	frame_length = (u32) (mode->signal_properties.pixel_clock.val *
-			      (u64) mode->control_properties.framerate_factor /
-			      mode->image_properties.line_length / val);
+	priv->frame_length = frame_length;
+	if (priv->frame_length > IMX477_MAX_FRAME_LENGTH)
+		priv->frame_length = IMX477_MAX_FRAME_LENGTH;
 
-	if (frame_length < IMX477_MIN_FRAME_LENGTH)
-		frame_length = IMX477_MIN_FRAME_LENGTH;
-	else if (frame_length > IMX477_MAX_FRAME_LENGTH)
-		frame_length = IMX477_MAX_FRAME_LENGTH;
+	dev_dbg(dev, "%s: val: %lld, , frame_length: %d\n", __func__,
+		val, priv->frame_length);
 
-	dev_dbg(dev,
-		"%s: val: %llde-6 [fps], frame_length: %u [lines]\n",
-		__func__, val, frame_length);
+	imx477_get_frame_length_regs(reg_list, priv->frame_length);
 
-	imx477_get_frame_length_regs(fl_regs, frame_length);
 	for (i = 0; i < 2; i++) {
-		err = imx477_write_reg(s_data, fl_regs[i].addr, fl_regs[i].val);
-		if (err) {
-			dev_err(dev,
-				"%s: frame_length control error\n", __func__);
-			return err;
-		}
+		err = imx477_write_reg(priv->s_data, reg_list[i].addr,
+			 reg_list[i].val);
+		if (err)
+			goto fail;
 	}
 
-	priv->frame_length = frame_length;
+	return 0;
 
+fail:
+	dev_dbg(dev, "%s: FRAME_LENGTH control error\n", __func__);
 	return err;
 }
 
 static int imx477_set_exposure(struct tegracam_device *tc_dev, s64 val)
 {
+	struct imx477 *priv = (struct imx477 *)tegracam_get_privdata(tc_dev);
 	struct camera_common_data *s_data = tc_dev->s_data;
-	struct imx477 *priv = (struct imx477 *)tc_dev->priv;
-	struct device *dev = tc_dev->dev;
 	const struct sensor_mode_properties *mode =
-	    &s_data->sensor_props.sensor_modes[s_data->mode_prop_idx];
-
-	int err = 0;
-	imx477_reg ct_regs[2];
-	const s32 max_coarse_time = priv->frame_length - IMX477_MAX_COARSE_DIFF;
-	const s32 fine_integ_time_factor = priv->fine_integ_time *
-	    mode->control_properties.exposure_factor /
-	    mode->signal_properties.pixel_clock.val;
+		&s_data->sensor_props.sensor_modes[s_data->mode];
+	imx477_reg reg_list[2];
+	int err;
 	u32 coarse_time;
-	int i;
-
-	dev_dbg(dev, "%s: Setting exposure control to: %lld\n", __func__, val);
+	int i = 0;
 
-	coarse_time = (val - fine_integ_time_factor)
-	    * mode->signal_properties.pixel_clock.val
-	    / mode->control_properties.exposure_factor
-	    / mode->image_properties.line_length;
-
-	if (coarse_time < IMX477_MIN_COARSE_EXPOSURE)
-		coarse_time = IMX477_MIN_COARSE_EXPOSURE;
-	else if (coarse_time > max_coarse_time) {
-		coarse_time = max_coarse_time;
-		dev_dbg(dev,
-			"%s: exposure limited by frame_length: %d [lines]\n",
-			__func__, max_coarse_time);
-	}
+	if (priv->frame_length == 0)
+		priv->frame_length = IMX477_DEFAULT_FRAME_LENGTH;
 
-	dev_dbg(dev, "%s: val: %lld [us], coarse_time: %d [lines]\n",
-		__func__, val, coarse_time);
+	/* coarse time in lines */
+	coarse_time = (u32) (val * s_data->frmfmt[s_data->mode].framerates[0] *
+		priv->frame_length / mode->control_properties.exposure_factor);
 
-	imx477_get_coarse_integ_time_regs(ct_regs, coarse_time);
+    if (coarse_time > priv->frame_length - 20)
+		coarse_time = priv->frame_length - 20;
+	dev_dbg(&priv->i2c_client->dev,
+		"%s: coarse time val:%d\n", __func__, coarse_time);
 
+	imx477_get_coarse_time_regs_shs1(reg_list, coarse_time);
 	for (i = 0; i < 2; i++) {
-		err = imx477_write_reg(s_data, ct_regs[i].addr, ct_regs[i].val);
-		if (err) {
-			dev_dbg(dev,
-				"%s: coarse_time control error\n", __func__);
-			return err;
-		}
+		err = imx477_write_reg(priv->s_data, reg_list[i].addr,
+			reg_list[i].val);
+		if (err)
+			goto fail;
 	}
 
+	return 0;
+
+fail:
+	dev_dbg(&priv->i2c_client->dev,
+		"%s: set coarse time error\n", __func__);
 	return err;
 }
 
@@ -328,64 +349,17 @@
 		return err;
 	}
 
+	/*exit reset mode: XCLR */
 	if (pw->reset_gpio) {
-		if (gpio_cansleep(pw->reset_gpio))
-			gpio_set_value_cansleep(pw->reset_gpio, 0);
-		else
-			gpio_set_value(pw->reset_gpio, 0);
-	}
-
-	if (unlikely(!(pw->avdd || pw->iovdd || pw->dvdd)))
-		goto skip_power_seqn;
-
-	usleep_range(10, 20);
-
-	if (pw->avdd) {
-		err = regulator_enable(pw->avdd);
-		if (err)
-			goto imx477_avdd_fail;
-	}
-
-	if (pw->iovdd) {
-		err = regulator_enable(pw->iovdd);
-		if (err)
-			goto imx477_iovdd_fail;
-	}
-
-	if (pw->dvdd) {
-		err = regulator_enable(pw->dvdd);
-		if (err)
-			goto imx477_dvdd_fail;
-	}
-
-	usleep_range(10, 20);
-
-skip_power_seqn:
-	if (pw->reset_gpio) {
-		if (gpio_cansleep(pw->reset_gpio))
-			gpio_set_value_cansleep(pw->reset_gpio, 1);
-		else
-			gpio_set_value(pw->reset_gpio, 1);
+		gpio_direction_output(pw->reset_gpio, 0);
+		usleep_range(30, 50);
+		gpio_direction_output(pw->reset_gpio, 1);
+		usleep_range(30, 50);
 	}
 
-	/* Need to wait for t4 + t5 + t9 + t10 time as per the data sheet */
-	/* t4 - 200us, t5 - 21.2ms, t9 - 1.2ms t10 - 270 ms */
-	usleep_range(300000, 300100);
-
 	pw->state = SWITCH_ON;
-
 	return 0;
 
-imx477_dvdd_fail:
-	regulator_disable(pw->iovdd);
-
-imx477_iovdd_fail:
-	regulator_disable(pw->avdd);
-
-imx477_avdd_fail:
-	dev_err(dev, "%s failed.\n", __func__);
-
-	return -ENODEV;
 }
 
 static int imx477_power_off(struct camera_common_data *s_data)
@@ -399,137 +373,72 @@
 
 	if (pdata && pdata->power_off) {
 		err = pdata->power_off(pw);
-		if (err) {
+		if (!err)
+			goto power_off_done;
+		else
 			dev_err(dev, "%s failed.\n", __func__);
-			return err;
-		}
-	} else {
-		if (pw->reset_gpio) {
-			if (gpio_cansleep(pw->reset_gpio))
-				gpio_set_value_cansleep(pw->reset_gpio, 0);
-			else
-				gpio_set_value(pw->reset_gpio, 0);
-		}
-
-		usleep_range(10, 10);
-
-		if (pw->dvdd)
-			regulator_disable(pw->dvdd);
-		if (pw->iovdd)
-			regulator_disable(pw->iovdd);
-		if (pw->avdd)
-			regulator_disable(pw->avdd);
+		return err;
 	}
+	/* enter reset mode: XCLR */
+	usleep_range(1, 2);
+	if (pw->reset_gpio)
+		gpio_direction_output(pw->reset_gpio, 0);
 
+power_off_done:
 	pw->state = SWITCH_OFF;
 
 	return 0;
 }
 
-static int imx477_power_put(struct tegracam_device *tc_dev)
-{
-	struct camera_common_data *s_data = tc_dev->s_data;
-	struct camera_common_power_rail *pw = s_data->power;
-
-	if (unlikely(!pw))
-		return -EFAULT;
-
-	if (likely(pw->dvdd))
-		devm_regulator_put(pw->dvdd);
-
-	if (likely(pw->avdd))
-		devm_regulator_put(pw->avdd);
-
-	if (likely(pw->iovdd))
-		devm_regulator_put(pw->iovdd);
-
-	pw->dvdd = NULL;
-	pw->avdd = NULL;
-	pw->iovdd = NULL;
-
-	if (likely(pw->reset_gpio))
-		gpio_free(pw->reset_gpio);
-
-	return 0;
-}
-
 static int imx477_power_get(struct tegracam_device *tc_dev)
 {
 	struct device *dev = tc_dev->dev;
 	struct camera_common_data *s_data = tc_dev->s_data;
 	struct camera_common_power_rail *pw = s_data->power;
 	struct camera_common_pdata *pdata = s_data->pdata;
+	const char *mclk_name;
 	struct clk *parent;
 	int err = 0;
 
-	if (!pdata) {
-		dev_err(dev, "pdata missing\n");
-		return -EFAULT;
+	mclk_name = pdata->mclk_name ?
+		    pdata->mclk_name : "extperiph1";
+	pw->mclk = devm_clk_get(dev, mclk_name);
+	if (IS_ERR(pw->mclk)) {
+		dev_err(dev, "unable to get clock %s\n", mclk_name);
+		return PTR_ERR(pw->mclk);
 	}
 
-	/* Sensor MCLK (aka. INCK) */
-	if (pdata->mclk_name) {
-		pw->mclk = devm_clk_get(dev, pdata->mclk_name);
-		if (IS_ERR(pw->mclk)) {
-			dev_err(dev, "unable to get clock %s\n",
-				pdata->mclk_name);
-			return PTR_ERR(pw->mclk);
-		}
-
-		if (pdata->parentclk_name) {
-			parent = devm_clk_get(dev, pdata->parentclk_name);
-			if (IS_ERR(parent)) {
-				dev_err(dev, "unable to get parent clock %s",
-					pdata->parentclk_name);
-			} else
-				clk_set_parent(pw->mclk, parent);
-		}
-	}
-
-	/* analog 2.8v */
-	if (pdata->regulators.avdd)
-		err |= camera_common_regulator_get(dev,
-						   &pw->avdd,
-						   pdata->regulators.avdd);
-	/* IO 1.8v */
-	if (pdata->regulators.iovdd)
-		err |= camera_common_regulator_get(dev,
-						   &pw->iovdd,
-						   pdata->regulators.iovdd);
-	/* dig 1.2v */
-	if (pdata->regulators.dvdd)
-		err |= camera_common_regulator_get(dev,
-						   &pw->dvdd,
-						   pdata->regulators.dvdd);
-	if (err) {
-		dev_err(dev, "%s: unable to get regulator(s)\n", __func__);
-		goto done;
-	}
+	parent = devm_clk_get(dev, "pllp_grtba");
+	if (IS_ERR(parent))
+		dev_err(dev, "devm_clk_get failed for pllp_grtba");
+	else
+		clk_set_parent(pw->mclk, parent);
 
-	/* Reset or ENABLE GPIO */
 	pw->reset_gpio = pdata->reset_gpio;
-	err = gpio_request(pw->reset_gpio, "cam_reset_gpio");
-	if (err < 0) {
-		dev_err(dev, "%s: unable to request reset_gpio (%d)\n",
-			__func__, err);
-		goto done;
-	}
 
-done:
 	pw->state = SWITCH_OFF;
-
 	return err;
 }
 
-static struct camera_common_pdata *imx477_parse_dt(struct tegracam_device
-						   *tc_dev)
+static int imx477_power_put(struct tegracam_device *tc_dev)
+{
+	struct camera_common_data *s_data = tc_dev->s_data;
+	struct camera_common_power_rail *pw = s_data->power;
+
+	if (unlikely(!pw))
+		return -EFAULT;
+
+	return 0;
+}
+
+static struct camera_common_pdata *imx477_parse_dt(struct tegracam_device *tc_dev)
 {
 	struct device *dev = tc_dev->dev;
 	struct device_node *np = dev->of_node;
 	struct camera_common_pdata *board_priv_pdata;
 	const struct of_device_id *match;
 	struct camera_common_pdata *ret = NULL;
-	int err = 0;
+	int err;
 	int gpio;
 
 	if (!np)
@@ -546,37 +455,24 @@
 	if (!board_priv_pdata)
 		return NULL;
 
+	err = of_property_read_string(np, "mclk",
+				      &board_priv_pdata->mclk_name);
+	if (err)
+		dev_err(dev, "mclk not in DT\n");
+
 	gpio = of_get_named_gpio(np, "reset-gpios", 0);
 	if (gpio < 0) {
 		if (gpio == -EPROBE_DEFER)
 			ret = ERR_PTR(-EPROBE_DEFER);
-		dev_err(dev, "reset-gpios not found\n");
+		dev_err(dev, "reset-gpios not found %d\n", err);
 		goto error;
 	}
 	board_priv_pdata->reset_gpio = (unsigned int)gpio;
 
-	err = of_property_read_string(np, "mclk", &board_priv_pdata->mclk_name);
-	if (err)
-		dev_dbg(dev, "mclk name not present, "
-			"assume sensor driven externally\n");
-
-	err = of_property_read_string(np, "avdd-reg",
-				      &board_priv_pdata->regulators.avdd);
-	err |= of_property_read_string(np, "iovdd-reg",
-				       &board_priv_pdata->regulators.iovdd);
-	err |= of_property_read_string(np, "dvdd-reg",
-				       &board_priv_pdata->regulators.dvdd);
-	if (err)
-		dev_dbg(dev, "avdd, iovdd and/or dvdd reglrs. not present, "
-			"assume sensor powered independently\n");
-
-	board_priv_pdata->has_eeprom = of_property_read_bool(np, "has-eeprom");
-
 	return board_priv_pdata;
 
 error:
 	devm_kfree(dev, board_priv_pdata);
-
 	return ret;
 }
 
@@ -584,16 +480,25 @@
 {
 	struct imx477 *priv = (struct imx477 *)tegracam_get_privdata(tc_dev);
 	struct camera_common_data *s_data = tc_dev->s_data;
+	struct device *dev = tc_dev->dev;
+	const struct of_device_id *match;
+	int err;
 
-	int err = 0;
+	dev_dbg(dev, "%s: %d: mode_prop_idx %d\n",
+		__func__, __LINE__, s_data->mode_prop_idx);
 
-	dev_dbg(tc_dev->dev, "%s:\n", __func__);
+	match = of_match_device(imx477_of_match, dev);
+	if (!match) {
+		dev_err(dev, "Failed to find matching dt id\n");
+		return -EINVAL;
+	}
+
+	imx477_write_table(priv, mode_table[IMX477_GLOBAL_SETTING]);
+	imx477_write_table(priv, mode_table[IMX477_IMAGE_QUALITY]);
+	imx477_write_table(priv, mode_table[IMX477_MODE_STOP_STREAM]);
 
-	err = imx477_write_table(priv, mode_table[IMX477_MODE_COMMON]);
-	if (err)
-		return err;
 
-	err = imx477_write_table(priv, mode_table[s_data->mode]);
+	err = imx477_write_table(priv, mode_table[s_data->mode_prop_idx]);
 	if (err)
 		return err;
 
@@ -603,22 +508,29 @@
 static int imx477_start_streaming(struct tegracam_device *tc_dev)
 {
 	struct imx477 *priv = (struct imx477 *)tegracam_get_privdata(tc_dev);
+	int err;
 
-	dev_dbg(tc_dev->dev, "%s:\n", __func__);
-	return imx477_write_table(priv, mode_table[IMX477_START_STREAM]);
+	err = imx477_write_table(priv,
+		mode_table[IMX477_MODE_START_STREAM]);
+	if (err)
+		return err;
+
+	return 0;
 }
 
 static int imx477_stop_streaming(struct tegracam_device *tc_dev)
 {
-	int err;
 	struct imx477 *priv = (struct imx477 *)tegracam_get_privdata(tc_dev);
+	int err;
 
-	dev_dbg(tc_dev->dev, "%s:\n", __func__);
-	err = imx477_write_table(priv, mode_table[IMX477_STOP_STREAM]);
+	err = imx477_write_table(priv, mode_table[IMX477_MODE_STOP_STREAM]);
+	if (err)
+		return err;
 
-	return err;
+	return 0;
 }
 
+
 static struct camera_common_sensor_ops imx477_common_ops = {
 	.numfrmfmts = ARRAY_SIZE(imx477_frmfmt),
 	.frmfmt_table = imx477_frmfmt,
@@ -638,45 +550,26 @@
 {
 	struct camera_common_data *s_data = priv->s_data;
 	struct device *dev = s_data->dev;
-	u8 reg_val[2];
 	int err = 0;
 
-	// Skip mclk enable as this camera has an internal oscillator
+	dev_dbg(dev, "%s++\n", __func__);
 
-	err = imx477_power_on(s_data);
+	err = camera_common_mclk_enable(s_data);
 	if (err) {
-		dev_err(dev, "error during power on sensor (%d)\n", err);
-		goto done;
+		dev_err(dev,
+			"Error %d turning on mclk\n", err);
+		return err;
 	}
 
-	/* Probe sensor model id registers */
-	err = imx477_read_reg(s_data, IMX477_MODEL_ID_ADDR_MSB, &reg_val[0]);
-	if (err) {
-		dev_err(dev, "%s: error during i2c read probe (%d)\n",
-			__func__, err);
-		goto err_reg_probe;
-	}
-	err = imx477_read_reg(s_data, IMX477_MODEL_ID_ADDR_LSB, &reg_val[1]);
+	err = imx477_power_on(s_data);
 	if (err) {
-		dev_err(dev, "%s: error during i2c read probe (%d)\n",
-			__func__, err);
-		goto err_reg_probe;
+		dev_err(dev,
+			"Error %d during power on sensor\n", err);
+		return err;
 	}
 
-	if (!((reg_val[0] == 0x00) && reg_val[1] == 0x00))
-		dev_err(dev, "%s: invalid sensor model id: %x%x\n",
-			__func__, reg_val[0], reg_val[1]);
-
-	/* Sensor fine integration time */
-	err = imx477_get_fine_integ_time(priv, &priv->fine_integ_time);
-	if (err)
-		dev_err(dev, "%s: error querying sensor fine integ. time\n",
-			__func__);
-
-err_reg_probe:
 	imx477_power_off(s_data);
-
-done:
+	camera_common_mclk_disable(s_data);
 	return err;
 }
 
@@ -701,16 +594,18 @@
 	struct imx477 *priv;
 	int err;
 
-	dev_dbg(dev, "probing v4l2 sensor at addr 0x%0x\n", client->addr);
+	dev_info(dev, "probing v4l2 sensor\n");
 
 	if (!IS_ENABLED(CONFIG_OF) || !client->dev.of_node)
 		return -EINVAL;
 
-	priv = devm_kzalloc(dev, sizeof(struct imx477), GFP_KERNEL);
+	priv = devm_kzalloc(dev,
+			sizeof(struct imx477), GFP_KERNEL);
 	if (!priv)
 		return -ENOMEM;
 
-	tc_dev = devm_kzalloc(dev, sizeof(struct tegracam_device), GFP_KERNEL);
+	tc_dev = devm_kzalloc(dev,
+			sizeof(struct tegracam_device), GFP_KERNEL);
 	if (!tc_dev)
 		return -ENOMEM;
 
@@ -744,12 +639,13 @@
 		return err;
 	}
 
-	dev_dbg(dev, "detected imx477 sensor\n");
+	dev_info(dev, "Detected IMX477 sensor\n");
 
 	return 0;
 }
 
-static int imx477_remove(struct i2c_client *client)
+static int
+imx477_remove(struct i2c_client *client)
 {
 	struct camera_common_data *s_data = to_camera_common_data(&client->dev);
 	struct imx477 *priv = (struct imx477 *)s_data->priv;
@@ -761,18 +657,18 @@
 }
 
 static const struct i2c_device_id imx477_id[] = {
-	{"imx477", 0},
-	{}
+	{ "imx477", 0 },
+	{ }
 };
 
 MODULE_DEVICE_TABLE(i2c, imx477_id);
 
 static struct i2c_driver imx477_i2c_driver = {
 	.driver = {
-		   .name = "imx477",
-		   .owner = THIS_MODULE,
-		   .of_match_table = of_match_ptr(imx477_of_match),
-		   },
+		.name = "imx477",
+		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(imx477_of_match),
+	},
 	.probe = imx477_probe,
 	.remove = imx477_remove,
 	.id_table = imx477_id,
@@ -781,5 +677,6 @@
 module_i2c_driver(imx477_i2c_driver);
 
 MODULE_DESCRIPTION("Media Controller driver for Sony IMX477");
-MODULE_AUTHOR("RidgeRun");
+MODULE_AUTHOR("Meng Gao <gaomeng@leopardimaging.com>");
 MODULE_LICENSE("GPL v2");
+
diff -Naur kernel/nvidia/drivers/media/i2c/imx477_mode_tbls.h kernel_new/nvidia/drivers/media/i2c/imx477_mode_tbls.h
--- kernel/nvidia/drivers/media/i2c/imx477_mode_tbls.h	2021-02-19 08:38:22.000000000 -0800
+++ kernel_new/nvidia/drivers/media/i2c/imx477_mode_tbls.h	2021-11-28 21:19:20.806965387 -0800
@@ -1,9 +1,9 @@
 /*
- * imx477_mode_tbls.h - imx477 sensor mode tables
+ * imx477.c - imx477 sensor driver
  *
- * Copyright (c) 2020, RidgeRun. All rights reserved.
+ * Copyright (c) 2016-2018, NVIDIA CORPORATION, All Rights Reserved.
  *
- * Contact us: support@ridgerun.com
+ * Copyright (c) 2016-2019, Guoxin Wu <guoxinw@leopardimaging.com>.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
@@ -23,6 +23,7 @@
 
 #include <media/camera_common.h>
 
+
 #define IMX477_TABLE_WAIT_MS 0
 #define IMX477_TABLE_END 1
 #define IMX477_WAIT_MS 1
@@ -31,6 +32,41 @@
 #define imx477_reg struct reg_8
 
 static const imx477_reg imx477_start[] = {
+
+	{0x3041, 0x01},
+	{0x3DAC, 0x01},
+	{0x3DAD, 0x00},
+	/* xvs signal */
+	{0x42A8, 0xFF},	/* TESTMNT0, fstrobe's signal by MNTTEST1_SEL */
+	{0x42A9, 0xFE},	/* TESTMNT1, xvs's signal by MNTTEST2_SEL */
+	{0x42AA, 0xFD},	/* TESTMNT2, gpo's signal by MNTTEST3_SEL */
+	/* MNTTEST2_SEL=22d, vsync is selected */
+	{0x4BD4, 0x00},
+	{0x4BD5, 0x16},
+	/* MNTTEST3_SEL=22d,vsync is selected */
+	{0x4BDC, 0x00},
+	{0x4BDD, 0x16},
+	/* MNTTEST3_SEL=21d,hsync is selected */
+	/* {0x4BDC,0x00}, */
+	/* {0x4BDD,0x15}, */
+	/* #else //V-SYNC signal */
+	{0x42B0, 0x00},	/* CKTESTSEL, monitor select */
+	{0x42A9, 0xFF},	/* TESTMNT1, xvs's signal */
+	{0x42AA, 0xFF},	/* TESTMNT2, gpo's signal by MNTTEST3_SEL */
+	/* MNTTEST1_SEL=22d, vsync is selected */
+	{0x4BD6, 0x00},
+	{0x4BD7, 0x16},
+	{0x4289, 0x00},	/* OUTIF1, xvs pin IO ctrl */
+	{0x4F0D, 0x07},	/* vsync pulse width */
+
+	{0x2160, 0x01},	/* xvs io ctrl,output */
+	{0x4B81, 0x01},	/* xvs out enable */
+	{0x4B82, 0x07},	/* XVS pulse width */
+	{0x4B83, 0x01},	/* XVS low active */
+	/* {0x4B83,0x00},//XVS high active */
+	{0x4270, 0x00},	/* gpiosel */
+	{0x42B0, 0x00},	/* CKTESTSEL, monitor select */
+
 	{IMX477_STANDBY_REG, 0x1},
 	{IMX477_TABLE_END, 0x00}
 };
@@ -40,10 +76,11 @@
 	{IMX477_TABLE_END, 0x00}
 };
 
-static const imx477_reg imx477_mode_common[] = {
+static const imx477_reg global_setting[] = {
 	{IMX477_TABLE_WAIT_MS, IMX477_WAIT_MS},
 	{0x0136, 0x18},
 	{0x0137, 0x00},
+
 	{0x0808, 0x02},
 	{0xE07A, 0x01},
 	{0xE000, 0x00},
@@ -128,19 +165,26 @@
 	{0xA006, 0x01},
 	{0xA007, 0xC0},
 	{0xA009, 0xC0},
-	{0x4bd5, 0x16},
-	{0x4bdd, 0x15},
-	{0x42b0, 0x00},
+	{0x4bd5, 22},
+	{0x4bdd, 21},
+	{0x42b0, 0x0},
 	{0x42a9, 0xfe},
 	{0x42aa, 0xfd},
-	{0x4270, 0x00},
-	{0x3040, 0x01},
+	{0x4270, 0x0},
+	{0x3040, 0x1},
+
+	{IMX477_TABLE_END, 0x0000}
+};
+
+static const imx477_reg image_qualitys[] = {
+
 	{0x3D8A, 0x01},
 	{0x7B3B, 0x01},
 	{0x7B4C, 0x00},
 	{0x9905, 0x00},
 	{0x9907, 0x00},
 	{0x9909, 0x00},
+
 	{0x990B, 0x00},
 	{0x9944, 0x3C},
 	{0x9947, 0x3C},
@@ -352,25 +396,26 @@
 	{0xB35C, 0x00},
 	{0xB35E, 0x08},
 	{IMX477_TABLE_END, 0x0000}
-
 };
 
-static const imx477_reg imx477_mode_4032x3040_30fps[] = {
+static const imx477_reg mode_1920X1080_60fps[] = {
 	{0x0112, 0x0A},
 	{0x0113, 0x0A},
 	{0x0114, 0x01},
+
 	{0x0342, 0x23},
 	{0x0343, 0x40},
-	{0x0340, 0x0C},
-	{0x0341, 0x1E},
+	/*MCLK 24MHz */
+	{0x0340, 0x06},
+	{0x0341, 0x0F},
 	{0x0344, 0x00},
 	{0x0345, 0x00},
-	{0x0346, 0x00},
-	{0x0347, 0x00},
+	{0x0346, 0x01},
+	{0x0347, 0x78},
 	{0x0348, 0x0F},
 	{0x0349, 0xD7},
-	{0x034A, 0x0B},
-	{0x034B, 0xDF},
+	{0x034A, 0x0A},
+	{0x034B, 0x67},
 	{0x00E3, 0x00},
 	{0x00E4, 0x00},
 	{0x00FC, 0x0A},
@@ -383,8 +428,8 @@
 	{0x0383, 0x01},
 	{0x0385, 0x01},
 	{0x0387, 0x01},
-	{0x0900, 0x00},
-	{0x0901, 0x11},
+	{0x0900, 0x01},
+	{0x0901, 0x22},
 	{0x0902, 0x02},
 	{0x3140, 0x02},
 	{0x3C00, 0x00},
@@ -413,20 +458,149 @@
 	{0x9E9E, 0x00},
 	{0x9E9F, 0x00},
 	{0xA2A9, 0x27},
+	/*Mode Setting*/
 	{0xA2B7, 0x03},
 	{0x0401, 0x00},
 	{0x0404, 0x00},
 	{0x0405, 0x10},
 	{0x0408, 0x00},
-	{0x0409, 0x0C},
+	{0x0409, 0x36},
+	{0x040A, 0x00},
+	{0x040B, 0x20},
+	{0x040C, 0x07},
+	{0x040D, 0x80},
+	{0x040E, 0x04},
+	{0x040F, 0x38},
+	{0x034C, 0x07},
+	{0x034D, 0x80},
+	{0x034E, 0x04},
+	{0x034F, 0x38},
+	{0x0301, 0x05},
+	{0x0303, 0x02},
+	{0x0305, 0x02},
+	{0x0306, 0x00},
+	{0x0307, 0xAF},
+	{0x0309, 0x0A},
+	{0x030B, 0x01},
+	{0x030D, 0x03},
+	{0x030E, 0x00},
+	{0x030F, 0x96},
+	{0x0310, 0x01},
+	{0x0820, 0x09},
+	{0x0821, 0x60},
+	{0x0822, 0x00},
+	{0x0823, 0x00},
+	{0x080A, 0x00},
+	{0x080B, 0x87},
+	{0x080C, 0x00},
+	{0x080D, 0x4F},
+	{0x080E, 0x00},
+	{0x080F, 0x87},
+	{0x0810, 0x00},
+	{0x0811, 0x5F},
+	{0x0812, 0x00},
+	{0x0813, 0x5F},
+	{0x0814, 0x00},
+	{0x0815, 0x4F},
+	{0x0816, 0x01},
+	{0x0817, 0x3F},
+	{0x0818, 0x00},
+	{0x0819, 0x3F},
+	{0xE04C, 0x00},
+	{0xE04D, 0x87},
+	{0xE04E, 0x00},
+	{0xE04F, 0x1F},
+
+	{0x3E20, 0x01},
+	{0x3E37, 0x00},
+
+	{0x3F50, 0x00},
+	{0x3F56, 0x01},
+	{0x3F57, 0x02},
+	{0X3FF9, 0x01},
+
+	{IMX477_TABLE_WAIT_MS, IMX477_WAIT_MS},
+	{IMX477_TABLE_END, 0x0000}
+};
+
+/* Mode 3 : 1920X1080 10 bits 60fps*/
+static const imx477_reg mode_4056X3040_30fps[] = {
+	{0x0112, 0x0A},
+	{0x0113, 0x0A},
+	{0x0114, 0x01},
+
+	{0x0342, 0x32},
+	{0x0343, 0xF8},
+	/* input freq. 24M */
+	{0x0340, 0x10},
+	{0x0341, 0xC3},
+	{0x0344, 0x00},
+	{0x0345, 0x00},
+	{0x0346, 0x00},
+	{0x0347, 0x00},
+	{0x0348, 0x0F},
+	{0x0349, 0xD7},
+	{0x034A, 0x0B},
+	{0x034B, 0xDF},
+
+	{0x00E3, 0x00},
+	{0x00E4, 0x00},
+	{0x00FC, 0x0A},
+	{0x00FD, 0x0A},
+	{0x00FE, 0x0A},
+	{0x00FF, 0x0A},
+	{0x0220, 0x00},
+	{0x0221, 0x11},
+	{0x0381, 0x01},
+	{0x0383, 0x01},
+	{0x0385, 0x01},
+	{0x0387, 0x01},
+	{0x0900, 0x00},
+	{0x0901, 0x11},
+	{0x0902, 0x02},
+	{0x3140, 0x02},
+	{0x3C00, 0x00},
+	{0x3C01, 0x03},
+	{0x3C02, 0xDC},
+	{0x3F0D, 0x00},
+	{0x5748, 0x07},
+	{0x5749, 0xFF},
+	{0x574A, 0x00},
+	{0x574B, 0x00},
+	{0x7B75, 0x0E},
+	{0x7B76, 0x09},
+	{0x7B77, 0x0C},
+	{0x7B78, 0x06},
+	{0x7B79, 0x3B},
+	{0x7B53, 0x01},
+	{0x9369, 0x5A},
+	{0x936B, 0x55},
+	{0x936D, 0x28},
+	{0x9304, 0x03},
+	{0x9305, 0x00},
+	{0x9E9A, 0x2F},
+	{0x9E9B, 0x2F},
+	{0x9E9C, 0x2F},
+	{0x9E9D, 0x00},
+	{0x9E9E, 0x00},
+	{0x9E9F, 0x00},
+	{0xA2A9, 0x60},
+	{0xA2B7, 0x00},
+	/* resolution */
+	{0x0401, 0x00},
+	{0x0404, 0x00},
+	{0x0405, 0x10},
+	{0x0408, 0x00},
+	{0x0409, 0x00},
 	{0x040A, 0x00},
 	{0x040B, 0x00},
 	{0x040C, 0x0F},
-	{0x040D, 0xC0},
+	{0x040D, 0xD8},
 	{0x040E, 0x0B},
 	{0x040F, 0xE0},
+	/* crop */
 	{0x034C, 0x0F},
-	{0x034D, 0xC0},
+	{0x034D, 0xD8},
 	{0x034E, 0x0B},
 	{0x034F, 0xE0},
 	{0x0301, 0x05},
@@ -436,60 +610,67 @@
 	{0x0307, 0xAF},
 	{0x0309, 0x0A},
 	{0x030B, 0x01},
-	{0x030D, 0x03},
-	{0x030E, 0x01},
-	{0x030F, 0x06},
+	/* mode setting */
+	{0x030D, 0x02},
+	{0x030E, 0x00},
+	{0x030F, 0x74},
 	{0x0310, 0x01},
-	{0x0820, 0x20},
+	{0x0820, 0x15},
 	{0x0821, 0xC0},
 	{0x0822, 0x00},
 	{0x0823, 0x00},
 	{0x080A, 0x00},
-	{0x080B, 0xC7},
+	{0x080B, 0x8F},
 	{0x080C, 0x00},
-	{0x080D, 0x87},
+	{0x080D, 0x5F},
 	{0x080E, 0x00},
-	{0x080F, 0xDF},
+	{0x080F, 0x97},
 	{0x0810, 0x00},
-	{0x0811, 0x97},
+	{0x0811, 0x6F},
 	{0x0812, 0x00},
-	{0x0813, 0x8F},
+	{0x0813, 0x67},
 	{0x0814, 0x00},
-	{0x0815, 0x7F},
-	{0x0816, 0x02},
-	{0x0817, 0x27},
+	{0x0815, 0x57},
+	{0x0816, 0x01},
+	{0x0817, 0x77},
 	{0x0818, 0x00},
-	{0x0819, 0x6F},
+	{0x0819, 0x4F},
 	{0xE04C, 0x00},
-	{0xE04D, 0xDF},
+	{0xE04D, 0x97},
 	{0xE04E, 0x00},
 	{0xE04F, 0x1F},
+
 	{0x3E20, 0x01},
 	{0x3E37, 0x00},
 	{0x3F50, 0x00},
 	{0x3F56, 0x00},
-	{0x3F57, 0x56},
+	{0x3F57, 0xBB},
 	{0X3FF9, 0x01},
+
 	{IMX477_TABLE_WAIT_MS, IMX477_WAIT_MS},
 	{IMX477_TABLE_END, 0x0000}
 };
 
-static const imx477_reg imx477_mode_1920x1080_60fps[] = {
+/* Mode 5 : 1288X546 10 bits 240fps*/
+static const imx477_reg mode_2028X1520_60fps[] = {
 	{0x0112, 0x0A},
 	{0x0113, 0x0A},
 	{0x0114, 0x01},
-	{0x0342, 0x23},
-	{0x0343, 0x40},
-	{0x0340, 0x06},
-	{0x0341, 0x0F},
+
+	{0x0342, 0x19},
+	{0x0343, 0x7C},
+	/* input freq. 24M */
+	{0x0340, 0x10},
+	{0x0341, 0xC3},
 	{0x0344, 0x00},
 	{0x0345, 0x00},
-	{0x0346, 0x01},
-	{0x0347, 0x78},
+	{0x0346, 0x00},
+	{0x0347, 0x00},
 	{0x0348, 0x0F},
 	{0x0349, 0xD7},
-	{0x034A, 0x0A},
-	{0x034B, 0x67},
+	{0x034A, 0x0B},
+	{0x034B, 0xDF},
+
 	{0x00E3, 0x00},
 	{0x00E4, 0x00},
 	{0x00FC, 0x0A},
@@ -507,47 +688,49 @@
 	{0x0902, 0x02},
 	{0x3140, 0x02},
 	{0x3C00, 0x00},
-	{0x3C01, 0x01},
-	{0x3C02, 0x9C},
+	{0x3C01, 0x03},
+	{0x3C02, 0xDC},
 	{0x3F0D, 0x00},
-	{0x5748, 0x00},
-	{0x5749, 0x00},
+	{0x5748, 0x07},
+	{0x5749, 0xFF},
 	{0x574A, 0x00},
-	{0x574B, 0xA4},
+	{0x574B, 0x00},
 	{0x7B75, 0x0E},
 	{0x7B76, 0x09},
-	{0x7B77, 0x08},
+	{0x7B77, 0x0C},
 	{0x7B78, 0x06},
-	{0x7B79, 0x34},
-	{0x7B53, 0x00},
-	{0x9369, 0x73},
-	{0x936B, 0x64},
-	{0x936D, 0x5F},
+	{0x7B79, 0x3B},
+	{0x7B53, 0x01},
+	{0x9369, 0x5A},
+	{0x936B, 0x55},
+	{0x936D, 0x28},
 	{0x9304, 0x03},
-	{0x9305, 0x80},
+	{0x9305, 0x00},
 	{0x9E9A, 0x2F},
 	{0x9E9B, 0x2F},
 	{0x9E9C, 0x2F},
 	{0x9E9D, 0x00},
 	{0x9E9E, 0x00},
 	{0x9E9F, 0x00},
-	{0xA2A9, 0x27},
-	{0xA2B7, 0x03},
+	{0xA2A9, 0x60},
+	{0xA2B7, 0x00},
+	/* resolution */
 	{0x0401, 0x00},
 	{0x0404, 0x00},
 	{0x0405, 0x10},
 	{0x0408, 0x00},
-	{0x0409, 0x36},
+	{0x0409, 0x00},
 	{0x040A, 0x00},
-	{0x040B, 0x20},
+	{0x040B, 0x00},
 	{0x040C, 0x07},
-	{0x040D, 0x80},
-	{0x040E, 0x04},
-	{0x040F, 0x38},
+	{0x040D, 0xEC},
+	{0x040E, 0x05},
+	{0x040F, 0xF0},
 	{0x034C, 0x07},
-	{0x034D, 0x80},
-	{0x034E, 0x04},
-	{0x034F, 0x38},
+	{0x034D, 0xEC},
+	{0x034E, 0x05},
+	{0x034F, 0xF0},
+	/* mode setting */
 	{0x0301, 0x05},
 	{0x0303, 0x02},
 	{0x0305, 0x02},
@@ -555,58 +738,68 @@
 	{0x0307, 0xAF},
 	{0x0309, 0x0A},
 	{0x030B, 0x01},
-	{0x030D, 0x03},
+	{0x030D, 0x02},
 	{0x030E, 0x00},
-	{0x030F, 0x96},
+	{0x030F, 0x74},
 	{0x0310, 0x01},
-	{0x0820, 0x09},
-	{0x0821, 0x60},
+	{0x0820, 0x15},
+	{0x0821, 0xC0},
 	{0x0822, 0x00},
 	{0x0823, 0x00},
 	{0x080A, 0x00},
-	{0x080B, 0x87},
+	{0x080B, 0x8F},
 	{0x080C, 0x00},
-	{0x080D, 0x4F},
+	{0x080D, 0x5F},
 	{0x080E, 0x00},
-	{0x080F, 0x87},
+	{0x080F, 0x97},
 	{0x0810, 0x00},
-	{0x0811, 0x5F},
+	{0x0811, 0x6F},
 	{0x0812, 0x00},
-	{0x0813, 0x5F},
+	{0x0813, 0x67},
 	{0x0814, 0x00},
-	{0x0815, 0x4F},
+	{0x0815, 0x57},
 	{0x0816, 0x01},
-	{0x0817, 0x3F},
+	{0x0817, 0x77},
 	{0x0818, 0x00},
-	{0x0819, 0x3F},
+	{0x0819, 0x4F},
 	{0xE04C, 0x00},
-	{0xE04D, 0x87},
+	{0xE04D, 0x97},
 	{0xE04E, 0x00},
 	{0xE04F, 0x1F},
 	{0x3E20, 0x01},
 	{0x3E37, 0x00},
 	{0x3F50, 0x00},
-	{0x3F56, 0x01},
-	{0x3F57, 0x02},
+	{0x3F56, 0x00},
+	{0x3F57, 0xBB},
 	{0X3FF9, 0x01},
 	{IMX477_TABLE_WAIT_MS, IMX477_WAIT_MS},
 	{IMX477_TABLE_END, 0x0000}
 };
 
 enum {
-	IMX477_MODE_4032x3040_30FPS,
-	IMX477_MODE_1920x1080_60FPS,
-	IMX477_MODE_COMMON,
-	IMX477_START_STREAM,
-	IMX477_STOP_STREAM,
+	IMX477_MODE_4056X3040,
+	IMX477_MODE_2028X1520,
+	IMX477_MODE_1920X1080,
+	IMX477_GLOBAL_SETTING,
+	IMX477_IMAGE_QUALITY,
+
+	IMX477_MODE_START_STREAM,
+	IMX477_MODE_STOP_STREAM,
 };
 
 static const imx477_reg *mode_table[] = {
-	[IMX477_MODE_4032x3040_30FPS] = imx477_mode_4032x3040_30fps,
-	[IMX477_MODE_1920x1080_60FPS] = imx477_mode_1920x1080_60fps,
-	[IMX477_MODE_COMMON] = imx477_mode_common,
-	[IMX477_START_STREAM] = imx477_start,
-	[IMX477_STOP_STREAM] = imx477_stop,
+	[IMX477_MODE_4056X3040] = mode_4056X3040_30fps,
+	[IMX477_MODE_2028X1520] = mode_2028X1520_60fps,
+	[IMX477_MODE_1920X1080] = mode_1920X1080_60fps,
+	[IMX477_GLOBAL_SETTING] = global_setting,
+	[IMX477_IMAGE_QUALITY] = image_qualitys,
+
+	[IMX477_MODE_START_STREAM]		= imx477_start,
+	[IMX477_MODE_STOP_STREAM]		= imx477_stop,
+};
+
+static const int imx477_15_fr[] = {
+	15,
 };
 
 static const int imx477_30_fr[] = {
@@ -618,7 +811,10 @@
 };
 
 static const struct camera_common_frmfmt imx477_frmfmt[] = {
-	{{4032, 3040}, imx477_30_fr, 1, 0, IMX477_MODE_4032x3040_30FPS},
-	{{1920, 1080}, imx477_60_fr, 1, 0, IMX477_MODE_1920x1080_60FPS},
+	{{4056, 3040}, imx477_15_fr, 1, 0, IMX477_MODE_4056X3040},
+	{{2028, 1520}, imx477_60_fr, 1, 0, IMX477_MODE_2028X1520},
+	{{1920, 1080}, imx477_60_fr, 1, 0, IMX477_MODE_1920X1080},
 };
-#endif /* __IMX477_I2C_TABLES__ */
+#endif  /* __IMX477_I2C_TABLES__ */
+
+
diff -Naur kernel/nvidia/drivers/media/platform/tegra/camera/vi/vi5_fops.c kernel_new/nvidia/drivers/media/platform/tegra/camera/vi/vi5_fops.c
--- kernel/nvidia/drivers/media/platform/tegra/camera/vi/vi5_fops.c	2021-02-19 08:38:22.000000000 -0800
+++ kernel_new/nvidia/drivers/media/platform/tegra/camera/vi/vi5_fops.c	2021-11-29 22:55:14.245209158 -0800
@@ -230,7 +230,7 @@
 	int ret = 0;
 
 	*nbuffers = clamp(*nbuffers, CAPTURE_MIN_BUFFERS, CAPTURE_MAX_BUFFERS);
-
+printk(">>>> vi5_channel_setup_queue,nbuffers=%d\n",*nbuffers);
 	ret = tegra_channel_alloc_buffer_queue(chan, *nbuffers);
 	if (ret < 0)
 		goto done;
@@ -382,6 +382,13 @@
 	struct timespec ts;
 	struct capture_descriptor *descr =
 		&chan->request[buf->capture_descr_index];
+    #if 1
+    struct timeval cur_time;
+    long start_time,endtime;
+    do_gettimeofday(&cur_time);
+    start_time = ((long)cur_time.tv_sec)*1000+(long)cur_time.tv_usec/1000;
+    printk(">>> start_time = %ld\n",start_time);
+    #endif
 
 	if (buf->vb2_state != VB2_BUF_STATE_ACTIVE)
 		goto rel_buf;
@@ -424,12 +431,17 @@
 	vb->timestamp.tv_sec = ts.tv_sec;
 	vb->timestamp.tv_usec = ts.tv_nsec / NSEC_PER_USEC;
 #else
+    printk(">>> sof:%ld\n",(ts.tv_sec * 1000 + (ts.tv_nsec / 1000000)));
+    do_gettimeofday(&cur_time);
+    endtime = ((long)cur_time.tv_sec)*1000+(long)cur_time.tv_usec/1000;
+    printk(">>> endtime = %ld\n",endtime);
 	vb->vb2_buf.timestamp = descr->status.sof_timestamp;
 #endif
 
 	/* Read EOF from capture descriptor */
 	ts = ns_to_timespec((s64)descr->status.eof_timestamp);
 	trace_tegra_channel_capture_frame("eof", ts);
+printk(">>> eof:%ld\n",(ts.tv_sec * 1000 + (ts.tv_nsec / 1000000)));
 
 done:
 	spin_lock_irqsave(&chan->capture_state_lock, flags);
diff -Naur kernel/nx.sh kernel_new/nx.sh
--- kernel/nx.sh	1969-12-31 16:00:00.000000000 -0800
+++ kernel_new/nx.sh	2021-11-28 21:24:00.796845403 -0800
@@ -0,0 +1,6 @@
+#!/bin/sh
+export CROSS_COMPILE=/opt/gcc-linaro-7.3.1-2018.05-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-
+export TEGRA_KERNEL_OUT=/home/work/nx/kernel/kernel_out
+export ARCH=arm64
+export LOCALVERSION=-tegra
+export TEGRA_X2_ROOTFS=/home/work/nx/Linux_for_Tegra/rootfs
